tests printer ok
refaire tests vaults & lending
revoir/documenter le code

- new features stiive: frax machin, formule numa price (POL in pools)
- doc, I need to confirm code from doc, give some feedbacks to doc and iterate on it with Stiive


*** à documenter

     - lending, maxborrow, UR, prix utilisés, liquidations, leverage
     - printer: prix utilisés, scaling, blocking, security, les cf_warning, cf_critical
     - les différents CF, par exemple CFwithoutdebt pour blocking?
     - formule security pour le debasing
     - quand est-ce qu'on appelle les accrueinterest
     - quand est-ce qu'on update le synthscaling

*** Questions en cours:

- numa min price

- POL formula

- check debasing/rebasing and security last check

-  j'update le snapshot avant devrais-le faire après l'operation?
juste un get avant si necessaire et puis un recalcul et update apres


pour les burn un get&update avant et un get&update apres
pour les autres OP un update apres

- liquidateborrow with too much

REVERT 
 if (isDeprecated(CToken(cTokenBorrowed))) {
            require(borrowBalance >= repayAmount, "Can not repay more than the total borrow");



+
            uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);
            if (repayAmount > maxClose) 
            {

--> à l'air OK














 réponses Stiive

a) nouvelle formula maxBorrow ???


CF_liquid = (rETH_liquid / (synthetic_rETHdebt)
CF_theoretical = (rETH_liquid + rETH_borrowed) / (synthetic_rETHdebt)





The intended outcome is that we ideally want maintain ~20% liquidity in the vault at all times so it doesn't all get borrowed. 



rEthLiquid > 20% x synthValue

maxBorrow at one time is rEth - borrow > 20% x synthValue

borrow <  rEth - 20%x synthValue

maxBorrow = rEth - 20%*SynthValue

--> agreed but

     - not with rEThBorrowed
     - maxBorrow means, if we reach it we are at 100% UR, so if we want to increase interest rate we would need to use the kink at 80% maybe




That is, CF_liquid should be >20%. This means there will always be some liquid rETH in the vault to account for vault sells and liquidation flashloan requirements.

Borrowing rETH is free until above 80% utilization where we start to increase the interest rate to encourage repayments... if 100% is borrowed, interest rate should be very high (like 100%+) to incentivise repayment.... 

but even at 100% utilization, we ideally still don't want to be left in a situation with NO liquid rETH in the vault...

So if we set that there is 20% left in the vault when utilization is at 100%, this means maxBorrow should occur when CF_liquid is at 20%.
So the formula could be:
maxBorrow = (rETH_liquid + rETH_borrowed) - 20% * synthetic_rETHdebt



Q:

- synthetic_rETHdebt is what I call "synth total value"?




b) changer l'usage des min avec vault_price
pb buy/sell fees are relative to a vault
c) minimum numa price --> Stiive doit reflechir encore
d) absorb and bad debt?
e) new numa pricing formula --> POL?


1) 

- tâches coding  --> TODO finir selon les réponses de stiive

- relire --> TODO relire toute la partie lending et mes modifs/voir ce que je peux virer
     - notes: getVaultBalance/getVaultBalanceNoDebt renvoient la même valeur quand la liquidité est locked
     --> confirmer qu'il n'y a pas de cas ou ça pose probleme (lock ou pas lock la valeur devrait être différente)

     --> j'ai ajouté RAWlocked, ça n'impacte que le maxborrow à voir s'il est sensé varier au couras d'un flashloan
          - liquidate, peut faire un repay, mais après le repay, pas de nouveau borrow --> OK
          - leverage, on va faire un borrow, mais pas de raison que le maxborrow ai changé avant ce borrow

          --> todo: confirmer
     - vault à partir de buyCtoken --> documenter/cleaner le code dans vault et dans lending contracts!!

     - TODO REVOIR TOUTES LES FEES DU PRINTER
--> ca a l'air ok mais tricky surtout pour la partie nuAsset--> numa car la fee est prise sur le numa
     - spot price remove?



     - absorb?

     - checker les tolerance du numaPrice, je les appliques au prix x amount --> c'est ok? DE PLUS, je les applique sur l'inverse du prix (numaPerETH)

     - TODO

2) tests

ajouter vault etc dans la nouvelle fixture, virer ce que je n'utilise pas
modulariser si necessaire

- numaoracle
     ** highest/lowest/getV3SqrtPriceAvg
	** getNbOfNumaNeeded lowest
     ** getNbOfNumaFromAsset highest
     ** getNbOfNuAsset lowest
     ** getNbOfAssetneeded highest
     ** + vault price bounds 
OK 
TODO manque les set + ownership

- printer
     ** les set
     ** getNbOfNuAssetFromNuma + check that we use lower numa price
     ** getNbOfNumaNeededAndFee  + check that we use higher numa price

     
     ** getNbOfnuAssetNeededForNuma + check that we use higher numa price + check scaling
     ** getNbOfNumaFromAssetWithFee/getNbOfNumaFromAssetWithFeeView + check that we use higher numa price + check scaling

     ** mintAssetOutputFromNuma: check blocking, check numa lowest

     ** burnAssetInputToNuma: check scaling, check numa price high

     ** burnAssetToNumaOutput: check scaling, check numa price high

     ** mintAssetFromNumaInput: check blocking, check numa lowest

     ** swapExactInput: check fees x 1

     ** swapExactOutput: check fees x 1


pool numa/eth, faire bouger le prix et le temps
vault global CF, synth supply




- vault/vaultmanager
- lending


3) revoir mes questions non répondues à Stiive







****************************** TASKS ************************************************

** coding


          ** call VM.accrueinterest a chaque mint/burn de nuasset
          OK
          ** call VM.accrueinterest à chaque chgt de balance du vault
               TODO si globlCF only, call vaultmanager accrueInterest + add the call in  repay/borrow as we change

--> mettre à jour le code quand stiive m'aura repondu sur le multi vault

--> are we sure it's enough (we should do it also when nuasset price changes)

--> todo si globalCF, maxCF global aussi?


- revoir le maxborrow, il n'utilise que lea balance du vault

- tout relire, printer, vault, vaultmanager, remettre des interfaces quand possible

     - passer les nuassets en non upgradable?


	- check int56(int32( cast


- virer les fichiers unused


- passer les nuassets en OFT

** divers


- numaoracle les arrondis ceiling etc... voir si tout est correct dans les 2 sens


- numaprinter: onpourrait reecrire la façon dont sont gérer les fees, pas très clair

- DOC 

     ** lister les trucs à documenter
           ** leverage comment ça marche avec le flashloan
           ** liquidations
           ** les differents CF et ce qui se passe selon

** tests numa printer/numa oracle

- arbi fork

- retester vault
- retester lending

- Autre fonctionnalités
- synth swaps + no scaling/noblocking

- refacto tests: fixtures: printer, vault, lending
         

         - refaire numaOracle

         - voir si besoin de refaire numaPrinter test, à minima le passer sur arbifork

         - verifier que numaOracle/numaPrinter est exhaustif

         - faire des fonctions d'init séparées: printer, vault, comp
         
         - à la fin il faudra ces tests là:
               - numa token
               - printer
               - oracle
               - vault
               - lending
               - synthetics swaps
          -  clip to numa VM price
     DONE: todo: check code, test code


- tester la wl de fees

** questions
- sended in telegram

- about security currentCF --> confirm what we do

- synthetics swaps --> use highest/lowest so when price changes during in the last 30 min --> swapper get rekt

** Notes Stiive





** deploy scripts




